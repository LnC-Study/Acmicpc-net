# 가장 먼 노드 (Level 3)

---

## 문제 설명

n개의 노드가 있는 그래프가 있습니다. 각 노드는 1부터 n까지 번호가 적혀있습니다. 1번 노드에서 가장 멀리 떨어진 노드의 갯수를 구하려고 합니다. 가장 멀리 떨어진 노드란 최단경로로 이동했을 때 간선의 개수가 가장 많은 노드들을 의미합니다.

노드의 개수 n, 간선에 대한 정보가 담긴 2차원 배열 vertex가 매개변수로 주어질 때, 1번 노드로부터 가장 멀리 떨어진 노드가 몇 개인지를 return 하도록 solution 함수를 작성해주세요.

---

### 제한사항

- 노드의 개수 n은 2 이상 20,000 이하입니다.
- 간선은 양방향이며 총 1개 이상 50,000개 이하의 간선이 있습니다.
- vertex 배열 각 행 [a, b]는 a번 노드와 b번 노드 사이에 간선이 있다는 의미입니다.

---

## 문제 해결 by 인준

너비 우선 검색(BFS, Breadth-First Search)는 가장 단순한 그래프 검색 알고리즘 중 하나이다. 너비 우선 검색은 주어진 그래프 *G* = (*V, E*)와 한 개의 구별되는 ***출발점***(*source*) *s*에 대해, 너비 우선 검색은 *s*로부터 도달할 수 있는 모든 정점을 "발견"하기 위해서 *G*의 간선을 체계적으로 탐색한다. 이것은 ***s*로 부터 도달할 수 있는 각 정점까지의 거리(가장 적은 간선의 수)를 계산**한다.

너비 우선 검색은 **진행 정도를 따라가기 위해 각 정점을 흰색, 회색 또는 검은색으로 칠해 나간다**. 모든 정점은 처음에 흰색으로 시작해 회색이 됐다가 다시 검은색이 된다.

정점은 검색 도중에 처음으로 ***발견***되면 이때 흰색이 아닌 다른 색으로 바뀐다. 그러므로 회색과 검은색의 정점은 이미 발견되었음을 의미하는데, 둘을 구분하는 것은 검색이 너비 우선 방법으로 수행되도록 보장하기 위해서다.

**(*u, v*) ∈ *E*이고 정점 *u*가 검은색이라면, 정점 *v*는 회색이거나 검은색**이다. 즉, 검은색 정점에 인접해 있는 모든 정점은 이미 발견된 것이다. 회색 정점은 인접한 흰색 정점을 가질 수 있는데 이는 발견된 정점과 발견되지 않은 정점 사이에 있는 경계선(frontier)을 나타낸다.

**모든 정점은 많아야 한 번씩만 발견되므로, 부모 정점은 많아야 각각 한 개**다.

위의 내용은 [**Introduction To Algorithms**](https://en.wikipedia.org/wiki/Introduction_to_Algorithms)에 포함된 내용이며, 이를 바탕으로 가장 먼 노드의 거리 max를 탐색하는 프로시저를 아래와 같이 설계하였다.

다음의 너비 우선 검색 프로시저 **BFS**는 입력 그래프 *G* = (*V, E*)가 인접 리스트를 이용해 표현된다고 가정한다. 이는 **그래프의 각 정점에 대해 다양한 추가 속성을 부여**한다. 각 정점 *u* ∈ *V*의 색은 속성 *u*.*color*에 저장되고 *u*의 직전 원소는 속성 *u*.*π*에 저장된다. *u*에 직전 원소가 없는 경우라면, *u.π*는 *null*이다. 속성 *u.d*는 이 알고리즘으로 계산된 출발점 *s*에서 정점 *u*까지의 거리를 저장한다. 이 알고리즘은 또한 회색 정점의 집합을 관리하기 위해 선입선출(first-in, first-out) 큐인 *Q*를 사용한다.

    **BFS**(*G, s*)
    
    1. *max* ← 0 
    2. **for each** *u* **in** *G.V* - {*s*}:
    3.        *u.color* ← WHITE
    4.        *u.d* ← ∞
    5.        *u.π* ← *null* 
    6.  *s.color* ← GRAY
    7.  *s.d* ← 0
    8.  *s.π* ← *null*
    9.  *Q* ← Empty Queue
    10.  **ENQUEUE**(*Q.s*)
    11.  **while** *Q* **is not** empty queue:
    12.        *u* ← **DEQUEUE**(*Q*)
    13.        **for each** *v* **in** *G.Adj*[*u*]:
    14.              **if** *v.color* **is** WHITE:
    15.                    *v.color* ← GRAY
    16.                    *v.d* ← *u.d* + 1
    17.                    *v.π* ← *u*
    18.                    **ENQUEUE**(*Q*, *v*)
    19.                    **if** *max* **is less than** *v.d*:
    20.                            *max* ← *v.d* 
    21.        *u.color* ← BLACK

하나의 인접 리스트에 포함되는 노드의 color가 변화할 때, 다른 인접 리스트에 포함되는 동일한 노드의 color 변화를 동기화 하기 위하여 동일한 노드를 참조하는 변수를 인접리스트에 추가하였다. 즉, 그래프 초기화 시 인접 리스트에 추가되는 각 노드에 대해 얕은 복사를 수행하여 heap 메모리 영역에 위치하는 동일한 인스턴스를 참조하게 하였다.

---